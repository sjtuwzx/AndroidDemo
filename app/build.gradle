import com.android.build.gradle.AppExtension
import com.android.build.gradle.AppPlugin

import java.text.SimpleDateFormat

apply plugin: 'com.android.application'
apply plugin: 'com.getkeepsafe.dexcount'
apply plugin: 'checkstyle'

android {
    compileSdkVersion 23
    buildToolsVersion "23.0.3"

    defaultConfig {
        applicationId "com.wzx.android.demo.v2"
        minSdkVersion 15
        targetSdkVersion 23
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:support-v4:+'
    compile 'com.android.support:appcompat-v7:23+'
    compile 'com.android.support:recyclerview-v7:+'
    compile 'com.android.support.constraint:constraint-layout:+'
    compile 'com.google.code.javaparser:javaparser:1.0.8'
    testCompile 'junit:junit:4.12'
}

afterEvaluate {
    task checkstyle(type: Checkstyle) {
        configFile file("${project.rootDir}/checkstyle.xml")
        source 'src'
        include '**/*.java'
        exclude '**/gen/**'

        classpath = files()
    }
    task checkstyleReport << {
        if (file("$buildDir/reports/checkstyle/checkstyle.xml").exists()) {
            ant.xslt(in: "$buildDir/reports/checkstyle/checkstyle.xml",
                    style: "${project.parent.projectDir.absolutePath}/buildsrc/checkstyle-noframes-sorted.xsl",
                    out: "$buildDir/reports/checkstyle/checkstyle.html"
            )
        }
    }
    gradle.taskGraph.afterTask { Task task, TaskState state ->
        if (state.failure) {
            if (task.name in ['checkstyle']) {
                checkstyleReport.execute()
            }
        }
    }

    //需要检查的时候在主工程运行 ./gradlew :android-nova-hotel:checkstyle --stacktrace
    //下面的代码是在bundleRelease的时候运行checkstyle
    /*((AppExtension)((AppPlugin) project.getPlugins().getPlugin(AppPlugin)).extension).
            applicationVariants.all {
        def preBuildTask = project.tasks.findByName("preBuild")
        def checkstyleTask = project.tasks.findByName("checkstyle")
        preBuildTask.doFirst {
            def start = System.currentTimeMillis();
            try {
                checkstyleTask.execute()
            } finally {
                println "[checkstyle] cost ${System.currentTimeMillis() - start} ms"
            }
        }
    }*/
}


int countDirectory(File file) {
    File[] files = file.listFiles()
    int count = 0
    files.each {
        if (it.isFile()) {
            count += countFile(it)
        } else {
            count += countDirectory(it)
        }
    }
    return count
}

int countFile(File file) {
    int count = 0
    if (!file.name.endsWith(".java")) {
        return 0
    }
    file.eachLine {
        count ++
    }
    return count
}


task countLines << {
    println "===============count line===============================";
    File source = new File(project.projectDir,"src/main/java")
    int count = countDirectory(source)
    StringBuilder sb = new StringBuilder();
    sb.append(project.getName()+ ":" + count).append("\n");
    println(project.getName()+ ":" + count)
    File[] modules = new File(source,"ctrip/android/hotel").listFiles()
    modules.each {
        int moduleSize = countDirectory(it)
        println("   " +it.name+":" + moduleSize)
        sb.append("   " +it.name+":" + moduleSize).append("\n");
    }
    Date date = new Date();
    java.text.SimpleDateFormat format = new SimpleDateFormat("yyy-dd-mm HH:mm:ss");
    String name = "lines.txt";
    File file = new File(project.projectDir,name);
    file.append("==============" + format.format(date) +"==============\n");
    file.append(sb);
}

void buildFileRepeatedCodesIndex(File file, HashMap <String, ArrayList<String>> repeatedCodesIndex, int repeatedLines) {
    if (!file.name.endsWith(".java")) {
        return;
    }
    List<String> lines = file.readLines();
    int N = lines.size();
    StringBuffer sb = new StringBuffer(128);
    for (int i = 0; i <= N - repeatedLines; i++) {
        int realLineCount = 0;
        for (int j = 0; j < repeatedLines; j++) {
            String line = lines.get(i + j).trim();
            if (!line.isEmpty()) {
                ++realLineCount;
            }
            sb.append(line).append("|");

        }
        if (realLineCount > repeatedLines / 2) {
            String key = sb.toString();
            sb.setLength(0);
            if (!repeatedCodesIndex.containsKey(key)) {
                ArrayList<String> linePaths = new ArrayList<>();
                repeatedCodesIndex.put(key, linePaths);
            }
            String value = file.getAbsolutePath() + ":" + (i + 1);
            ArrayList<String> linePaths = repeatedCodesIndex.get(key);
            linePaths.add(value);
        }
    }
}

void buildDirectoryRepeatedCodesIndex(File file, HashMap <String, ArrayList<String>> repeatedCodesIndex, int repeatedLines) {
    File[] files = file.listFiles()
    files.each {
        if (it.isFile()) {
            buildFileRepeatedCodesIndex(it, repeatedCodesIndex, repeatedLines);
        } else {
            buildDirectoryRepeatedCodesIndex(it, repeatedCodesIndex, repeatedLines);
        }
    }
}

HashMap<String, ArrayList<String>> buildRepeatedCodesIndex(int repeatedLines) {
    HashMap <String, ArrayList<String>> repeatedCodesIndex = new HashMap<>();
    File source = new File(project.projectDir,"src/main/java/ctrip/android/hotel");
    buildDirectoryRepeatedCodesIndex(source, repeatedCodesIndex, repeatedLines);

    return repeatedCodesIndex;
}

void printRepeatedCodeInfo(ArrayList<String> linePaths) {
    println "=============================================="
    for (String linePath : linePaths) {
        println linePath;
    }
    println "==============================================\n";
}

task findRepeatedCodes << {
    println "===============find repeated codes===============================";
    HashMap<String, ArrayList<String>> repeatedCodesIndex = buildRepeatedCodesIndex(50);

    Set<String> keySet = repeatedCodesIndex.keySet();
    for (String key : keySet) {
        ArrayList<String> linePaths = repeatedCodesIndex.get(key);
        if (linePaths.size() > 1) {
            printRepeatedCodeInfo(linePaths);
        }
    }
}
